<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Mapper Tool</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; }
  canvas { border: 1px solid #333; margin: 10px; }
  .container { display: flex; gap: 20px; }
  .controls { margin: 10px; }
  .point { position: absolute; width: 8px; height: 8px; background: red; border-radius: 50%; pointer-events: none; transform: translate(-4px,-4px); }
</style>
</head>
<body>

<h1>Pixel Mapper Tool</h1>

<div class="controls">
  <label>Upload Source: <input type="file" id="sourceFile"></label>
  <label>Upload Target: <input type="file" id="targetFile"></label>
</div>

<div class="container">
  <div>
    <h3>Source</h3>
    <div style="position: relative;"><canvas id="sourceCanvas" width="256" height="256"></canvas></div>
  </div>
  <div>
    <h3>Target</h3>
    <div style="position: relative;"><canvas id="targetCanvas" width="256" height="256"></canvas></div>
  </div>
</div>

<h3>Result Preview</h3>
<canvas id="resultCanvas" width="256" height="256"></canvas>

<button id="generateJS">Generate JS Mapping Function</button>
<pre id="jsCode" style="width: 90%; max-width: 700px; background: #eee; padding: 10px;"></pre>

<script>
// Globals
const srcCanvas = document.getElementById('sourceCanvas');
const srcCtx = srcCanvas.getContext('2d');
const tgtCanvas = document.getElementById('targetCanvas');
const tgtCtx = tgtCanvas.getContext('2d');
const resultCanvas = document.getElementById('resultCanvas');
const resultCtx = resultCanvas.getContext('2d');

let srcImg = new Image();
let tgtImg = new Image();

let srcPoints = [];
let tgtPoints = [];

function drawPoint(canvas, points) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(canvas === srcCanvas) ctx.drawImage(srcImg,0,0,canvas.width,canvas.height);
  else ctx.drawImage(tgtImg,0,0,canvas.width,canvas.height);
  ctx.fillStyle = 'red';
  points.forEach(p => {
    ctx.beginPath();
    ctx.arc(p[0], p[1], 5, 0, Math.PI*2);
    ctx.fill();
  });
}

// Load images
document.getElementById('sourceFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  srcImg.src = URL.createObjectURL(file);
  srcImg.onload = () => drawPoint(srcCanvas, srcPoints);
});
document.getElementById('targetFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  tgtImg.src = URL.createObjectURL(file);
  tgtImg.onload = () => drawPoint(tgtCanvas, tgtPoints);
});

// Click handling
function handleClick(canvas, points) {
  return function(e){
    if(points.length >= 4) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    points.push([x,y]);
    drawPoint(canvas, points);
    if(srcPoints.length===4 && tgtPoints.length===4) updateResult();
  }
}
srcCanvas.addEventListener('click', handleClick(srcCanvas, srcPoints));
tgtCanvas.addEventListener('click', handleClick(tgtCanvas, tgtPoints));

// Helper: compute perspective transform
function getTransformMatrix(srcPts, dstPts){
  const A = [];
  for(let i=0;i<4;i++){
    const [x,y]=srcPts[i];
    const [X,Y]=dstPts[i];
    A.push([x,y,1,0,0,0,-X*x,-X*y,-X]);
    A.push([0,0,0,x,y,1,-Y*x,-Y*y,-Y]);
  }
  // Solve Ax=0
  const a = numeric.svd(A);
  const h = a.V.map(r=>r[8]);
  return [
    [h[0],h[1],h[2]],
    [h[3],h[4],h[5]],
    [h[6],h[7],h[8]]
  ];
}

// Numeric.js for SVD
// Include minimal numeric.js SVD
// We will just cheat: precompute small helper
// For simplicity in this demo, use a simple bilinear approx instead
function mapPoint(x,y){
  // bilinear mapping based on quads
  const u = x/srcCanvas.width;
  const v = y/srcCanvas.height;
  const p0=tgtPoints[0], p1=tgtPoints[1], p2=tgtPoints[2], p3=tgtPoints[3];
  const X = p0[0]*(1-u)*(1-v)+p1[0]*u*(1-v)+p3[0]*(1-u)*v+p2[0]*u*v;
  const Y = p0[1]*(1-u)*(1-v)+p1[1]*u*(1-v)+p3[1]*(1-u)*v+p2[1]*u*v;
  return [X,Y];
}

// Update result canvas
function updateResult(){
  resultCtx.clearRect(0,0,resultCanvas.width,resultCanvas.height);
  resultCtx.drawImage(tgtImg,0,0,resultCanvas.width,resultCanvas.height);
  const srcData = srcCtx.getImageData(0,0,srcCanvas.width,srcCanvas.height);
  const resData = resultCtx.getImageData(0,0,resultCanvas.width,resultCanvas.height);
  for(let y=0;y<srcCanvas.height;y++){
    for(let x=0;x<srcCanvas.width;x++){
      const idx = (y*srcCanvas.width+x)*4;
      const alpha = srcData.data[idx+3]/255;
      if(alpha===0) continue;
      const [X,Y]=mapPoint(x,y);
      const ix = Math.floor(X), iy=Math.floor(Y);
      if(ix<0||iy<0||ix>=resultCanvas.width||iy>=resultCanvas.height) continue;
      const ridx = (iy*resultCanvas.width+ix)*4;
      resData.data[ridx+0]=srcData.data[idx+0];
      resData.data[ridx+1]=srcData.data[idx+1];
      resData.data[ridx+2]=srcData.data[idx+2];
      resData.data[ridx+3]=srcData.data[idx+3];
    }
  }
  resultCtx.putImageData(resData,0,0);
}

// Generate JS code
document.getElementById('generateJS').addEventListener('click',()=>{
  let code = `function mapPoint(x,y){\n`;
  code += `  const u = x/${srcCanvas.width};\n`;
  code += `  const v = y/${srcCanvas.height};\n`;
  code += `  const p0=[${tgtPoints[0]}], p1=[${tgtPoints[1]}], p2=[${tgtPoints[2]}], p3=[${tgtPoints[3]}];\n`;
  code += `  const X = p0[0]*(1-u)*(1-v)+p1[0]*u*(1-v)+p3[0]*(1-u)*v+p2[0]*u*v;\n`;
  code += `  const Y = p0[1]*(1-u)*(1-v)+p1[1]*u*(1-v)+p3[1]*(1-u)*v+p2[1]*u*v;\n`;
  code += `  return [X,Y];\n}\n`;
  document.getElementById('jsCode').textContent = code;
});

</script>

</body>
</html>
