<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Mapper Tool - Multiple Quads</title>
<style>
body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; }
canvas { border: 1px solid #333; margin: 10px; }
.container { display: flex; gap: 20px; }
.controls { margin: 10px; }
button { margin: 2px; }
.mapping-item { margin: 5px 0; }
.point { position: absolute; width: 8px; height: 8px; background: red; border-radius: 50%; pointer-events: none; transform: translate(-4px,-4px); }
</style>
</head>
<body>

<h1>Pixel Mapper Tool - Multiple Quads</h1>

<div class="controls">
  <label>Upload Source: <input type="file" id="sourceFile"></label>
  <label>Upload Target: <input type="file" id="targetFile"></label>
</div>

<div class="container">
  <div>
    <h3>Source</h3>
    <canvas id="sourceCanvas" width="256" height="256"></canvas>
  </div>
  <div>
    <h3>Target</h3>
    <canvas id="targetCanvas" width="256" height="256"></canvas>
  </div>
</div>

<div class="controls">
  <button id="addMapping">Add Mapping</button>
  <button id="deleteMapping">Delete Current Mapping</button>
</div>

<div>
  <h3>Mappings</h3>
  <select id="mappingList" size="5" style="width:200px;"></select>
</div>

<h3>Result Preview</h3>
<canvas id="resultCanvas" width="256" height="256"></canvas>

<button id="generateJS">Generate JS Mapping Function</button>
<pre id="jsCode" style="width: 90%; max-width: 700px; background: #eee; padding: 10px;"></pre>

<script>
// Globals
const srcCanvas = document.getElementById('sourceCanvas');
const srcCtx = srcCanvas.getContext('2d');
const tgtCanvas = document.getElementById('targetCanvas');
const tgtCtx = tgtCanvas.getContext('2d');
const resultCanvas = document.getElementById('resultCanvas');
const resultCtx = resultCanvas.getContext('2d');

let srcImg = new Image();
let tgtImg = new Image();

// Mapping structure: array of {srcPoints: [[x,y],...], tgtPoints: [[x,y],...]}
let mappings = [];
let currentMapping = null;

document.getElementById('sourceFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  srcImg.src = URL.createObjectURL(file);
  srcImg.onload = () => updateCanvas();
});
document.getElementById('targetFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  tgtImg.src = URL.createObjectURL(file);
  tgtImg.onload = () => updateCanvas();
});

function updateCanvas(){
  srcCtx.clearRect(0,0,srcCanvas.width,srcCanvas.height);
  tgtCtx.clearRect(0,0,tgtCanvas.width,tgtCanvas.height);
  resultCtx.clearRect(0,0,resultCanvas.width,resultCanvas.height);
  if(srcImg.src) srcCtx.drawImage(srcImg,0,0,srcCanvas.width,srcCanvas.height);
  if(tgtImg.src) tgtCtx.drawImage(tgtImg,0,0,tgtCanvas.width,tgtCanvas.height);
  updateResult();
  drawMappingPoints();
}

function drawMappingPoints(){
  updateCanvas(); // draw images first
  mappings.forEach((map, idx)=>{
    const color = (idx===currentMapping)?'lime':'red';
    [srcCanvas,tgtCanvas].forEach((c,i)=>{
      const ctx = c.getContext('2d');
      ctx.fillStyle = color;
      const pts = (i===0)?map.srcPoints:map.tgtPoints;
      pts.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p[0],p[1],5,0,Math.PI*2);
        ctx.fill();
      });
    });
  });
}

// Mouse clicks
function canvasClick(canvas){
  return function(e){
    if(currentMapping===null) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    let pointsArray = (canvas===srcCanvas)?mappings[currentMapping].srcPoints:mappings[currentMapping].tgtPoints;
    if(pointsArray.length>=4) return;
    pointsArray.push([x,y]);
    drawMappingPoints();
    updateResult();
  }
}
srcCanvas.addEventListener('click', canvasClick(srcCanvas));
tgtCanvas.addEventListener('click', canvasClick(tgtCanvas));

// Add/delete mapping
document.getElementById('addMapping').addEventListener('click', ()=>{
  mappings.push({srcPoints:[], tgtPoints:[]});
  currentMapping = mappings.length-1;
  updateMappingList();
});
document.getElementById('deleteMapping').addEventListener('click', ()=>{
  if(currentMapping!==null){
    mappings.splice(currentMapping,1);
    currentMapping = (mappings.length>0)?0:null;
    updateMappingList();
    drawMappingPoints();
    updateResult();
  }
});

const mappingList = document.getElementById('mappingList');
function updateMappingList(){
  mappingList.innerHTML='';
  mappings.forEach((m,i)=>{
    const opt = document.createElement('option');
    opt.value=i; opt.text=`Mapping ${i+1}`;
    if(i===currentMapping) opt.selected=true;
    mappingList.appendChild(opt);
  });
}
mappingList.addEventListener('change', ()=>{ currentMapping = parseInt(mappingList.value); drawMappingPoints(); });

// Helper: point-in-quad using barycentric coords
function pointInQuad(px,py,quad){
  const [[x0,y0],[x1,y1],[x2,y2],[x3,y3]] = quad;
  const minX = Math.min(x0,x1,x2,x3), maxX=Math.max(x0,x1,x2,x3);
  const minY = Math.min(y0,y1,y2,y3), maxY=Math.max(y0,y1,y2,y3);
  return px>=minX && px<=maxX && py>=minY && py<=maxY;
}

// Bilinear mapping
function mapBilinear(x,y,srcQuad,dstQuad){
  const u = (x - srcQuad[0][0]) / (srcQuad[1][0]-srcQuad[0][0]||1);
  const v = (y - srcQuad[0][1]) / (srcQuad[3][1]-srcQuad[0][1]||1);
  const X = dstQuad[0][0]*(1-u)*(1-v)+dstQuad[1][0]*u*(1-v)+dstQuad[3][0]*(1-u)*v+dstQuad[2][0]*u*v;
  const Y = dstQuad[0][1]*(1-u)*(1-v)+dstQuad[1][1]*u*(1-v)+dstQuad[3][1]*(1-u)*v+dstQuad[2][1]*u*v;
  return [X,Y];
}

// Update result
function updateResult(){
  if(!tgtImg.src) return;
  resultCtx.clearRect(0,0,resultCanvas.width,resultCanvas.height);
  resultCtx.drawImage(tgtImg,0,0,resultCanvas.width,resultCanvas.height);
  const resData = resultCtx.getImageData(0,0,resultCanvas.width,resultCanvas.height);
  const srcData = srcCtx.getImageData(0,0,srcCanvas.width,srcCanvas.height);
  mappings.forEach(map=>{
    if(map.srcPoints.length<4 || map.tgtPoints.length<4) return;
    for(let y=0;y<srcCanvas.height;y++){
      for(let x=0;x<srcCanvas.width;x++){
        if(!pointInQuad(x,y,map.srcPoints)) continue;
        const idx = (y*srcCanvas.width+x)*4;
        const alpha = srcData.data[idx+3]/255;
        if(alpha===0) continue;
        const [X,Y]=mapBilinear(x,y,map.srcPoints,map.tgtPoints);
        const ix = Math.floor(X), iy=Math.floor(Y);
        if(ix<0||iy<0||ix>=resultCanvas.width||iy>=resultCanvas.height) continue;
        const ridx = (iy*resultCanvas.width+ix)*4;
        resData.data[ridx+0]=srcData.data[idx+0];
        resData.data[ridx+1]=srcData.data[idx+1];
        resData.data[ridx+2]=srcData.data[idx+2];
        resData.data[ridx+3]=srcData.data[idx+3];
      }
    }
  });
  resultCtx.putImageData(resData,0,0);
}

// Generate JS
document.getElementById('generateJS').addEventListener('click',()=>{
  let code='';
  mappings.forEach((map,i)=>{
    if(map.srcPoints.length<4 || map.tgtPoints.length<4) return;
    code+=`// Mapping ${i+1}\n`;
    code+=`const src${i}=${JSON.stringify(map.srcPoints)};\n`;
    code+=`const tgt${i}=${JSON.stringify(map.tgtPoints)};\n`;
  });
  code+=`
function mapPoint(x,y,mapping){
  const src=mapping.src, dst=mapping.dst;
  const u=(x-src[0][0])/(src[1][0]-src[0][0]||1);
  const v=(y-src[0][1])/(src[3][1]-src[0][1]||1);
  const X=dst[0][0]*(1-u)*(1-v)+dst[1][0]*u*(1-v)+dst[3][0]*(1-u)*v+dst[2][0]*u*v;
  const Y=dst[0][1]*(1-u)*(1-v)+dst[1][1]*u*(1-v)+dst[3][1]*(1-u)*v+dst[2][1]*u*v;
  return [X,Y];
}\n`;
  document.getElementById('jsCode').textContent = code;
});

</script>

</body>
</html>
