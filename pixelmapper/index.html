<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pixel Mapper Tool - Multiple Quads Fixed</title>
<style>
body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; }
canvas { border: 1px solid #333; margin: 10px; }
.container { display: flex; gap: 20px; }
.controls { margin: 10px; }
button { margin: 2px; }
</style>
</head>
<body>

<h1>Pixel Mapper Tool - Multiple Quads Fixed</h1>

<div class="controls">
  <label>Upload Source: <input type="file" id="sourceFile"></label>
  <label>Upload Target: <input type="file" id="targetFile"></label>
</div>

<div class="container">
  <div>
    <h3>Source</h3>
    <canvas id="sourceCanvas" width="256" height="256"></canvas>
  </div>
  <div>
    <h3>Target</h3>
    <canvas id="targetCanvas" width="256" height="256"></canvas>
  </div>
</div>

<div class="controls">
  <button id="addMapping">Add Mapping</button>
  <button id="deleteMapping">Delete Current Mapping</button>
</div>

<div>
  <h3>Mappings</h3>
  <select id="mappingList" size="5" style="width:200px;"></select>
</div>

<h3>Result Preview</h3>
<canvas id="resultCanvas" width="256" height="256"></canvas>

<button id="generateJS">Generate JS Mapping Function</button>
<pre id="jsCode" style="width: 90%; max-width: 700px; background: #eee; padding: 10px;"></pre>

<script>
// Globals
const srcCanvas = document.getElementById('sourceCanvas');
const srcCtx = srcCanvas.getContext('2d');
const tgtCanvas = document.getElementById('targetCanvas');
const tgtCtx = tgtCanvas.getContext('2d');
const resultCanvas = document.getElementById('resultCanvas');
const resultCtx = resultCanvas.getContext('2d');

let srcImg = new Image();
let tgtImg = new Image();

let mappings = [];
let currentMapping = null;

// Upload images
document.getElementById('sourceFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  srcImg.src = URL.createObjectURL(file);
  srcImg.onload = () => drawAll();
});
document.getElementById('targetFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  tgtImg.src = URL.createObjectURL(file);
  tgtImg.onload = () => drawAll();
});

// Add/Delete mappings
document.getElementById('addMapping').addEventListener('click', ()=>{
  mappings.push({srcPoints:[], tgtPoints:[]});
  currentMapping = mappings.length-1;
  updateMappingList();
  drawAll();
});
document.getElementById('deleteMapping').addEventListener('click', ()=>{
  if(currentMapping===null) return;
  mappings.splice(currentMapping,1);
  currentMapping = (mappings.length>0)?0:null;
  updateMappingList();
  drawAll();
});

// Mapping list selection
const mappingList = document.getElementById('mappingList');
function updateMappingList(){
  mappingList.innerHTML='';
  mappings.forEach((m,i)=>{
    const opt = document.createElement('option');
    opt.value=i; opt.text=`Mapping ${i+1}`;
    if(i===currentMapping) opt.selected=true;
    mappingList.appendChild(opt);
  });
}
mappingList.addEventListener('change', ()=>{ currentMapping=parseInt(mappingList.value); drawAll(); });

// Canvas click handler
function canvasClickHandler(canvas, isSource){
  return function(e){
    if(currentMapping===null) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width/rect.width);
    const y = (e.clientY - rect.top) * (canvas.height/rect.height);
    const pts = isSource?mappings[currentMapping].srcPoints:mappings[currentMapping].tgtPoints;
    if(pts.length>=4) return;
    pts.push([x,y]);
    drawAll();
    drawResult();
  }
}
srcCanvas.addEventListener('click', canvasClickHandler(srcCanvas,true));
tgtCanvas.addEventListener('click', canvasClickHandler(tgtCanvas,false));

// Draw images + mapping points + quad lines
function drawCanvas(canvas, ctx, img, points){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(img.src) ctx.drawImage(img,0,0,canvas.width,canvas.height);
  if(points.length>0){
    ctx.fillStyle='red';
    points.forEach(p=>{
      ctx.beginPath();
      ctx.arc(p[0],p[1],5,0,2*Math.PI);
      ctx.fill();
    });
    if(points.length===4){
      ctx.strokeStyle='yellow';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(points[0][0],points[0][1]);
      for(let i=1;i<4;i++) ctx.lineTo(points[i][0],points[i][1]);
      ctx.closePath();
      ctx.stroke();
    }
  }
}

// Draw all canvases
function drawAll(){
  drawCanvas(srcCanvas, srcCtx, srcImg, (currentMapping!==null)?mappings[currentMapping].srcPoints:[]);
  drawCanvas(tgtCanvas, tgtCtx, tgtImg, (currentMapping!==null)?mappings[currentMapping].tgtPoints:[]);
  drawResult();
}

// Point in quad check
function pointInQuad(px,py,quad){
  if(quad.length<4) return false;
  const xs = quad.map(p=>p[0]);
  const ys = quad.map(p=>p[1]);
  return px>=Math.min(...xs) && px<=Math.max(...xs) && py>=Math.min(...ys) && py<=Math.max(...ys);
}

// Bilinear mapping
function mapBilinear(x,y,srcQuad,dstQuad){
  const u = (x - srcQuad[0][0]) / (srcQuad[1][0]-srcQuad[0][0]||1);
  const v = (y - srcQuad[0][1]) / (srcQuad[3][1]-srcQuad[0][1]||1);
  const X = dstQuad[0][0]*(1-u)*(1-v)+dstQuad[1][0]*u*(1-v)+dstQuad[3][0]*(1-u)*v+dstQuad[2][0]*u*v;
  const Y = dstQuad[0][1]*(1-u)*(1-v)+dstQuad[1][1]*u*(1-v)+dstQuad[3][1]*(1-u)*v+dstQuad[2][1]*u*v;
  return [X,Y];
}

// Draw result canvas
function drawResult(){
  if(!tgtImg.src) return;
  resultCtx.clearRect(0,0,resultCanvas.width,resultCanvas.height);
  resultCtx.drawImage(tgtImg,0,0,resultCanvas.width,resultCanvas.height);
  const resData = resultCtx.getImageData(0,0,resultCanvas.width,resultCanvas.height);
  const srcData = srcCtx.getImageData(0,0,srcCanvas.width,srcCanvas.height);
  mappings.forEach(map=>{
    if(map.srcPoints.length<4 || map.tgtPoints.length<4) return;
    for(let y=0;y<srcCanvas.height;y++){
      for(let x=0;x<srcCanvas.width;x++){
        if(!pointInQuad(x,y,map.srcPoints)) continue;
        const idx = (y*srcCanvas.width+x)*4;
        const alpha = srcData.data[idx+3]/255;
        if(alpha===0) continue;
        const [X,Y]=mapBilinear(x,y,map.srcPoints,map.tgtPoints);
        const ix=Math.floor(X), iy=Math.floor(Y);
        if(ix<0||iy<0||ix>=resultCanvas.width||iy>=resultCanvas.height) continue;
        const ridx = (iy*resultCanvas.width+ix)*4;
        resData.data[ridx+0]=srcData.data[idx+0];
        resData.data[ridx+1]=srcData.data[idx+1];
        resData.data[ridx+2]=srcData.data[idx+2];
        resData.data[ridx+3]=srcData.data[idx+3];
      }
    }
  });
  resultCtx.putImageData(resData,0,0);
}

// Generate JS
document.getElementById('generateJS').addEventListener('click',()=>{
  let code='';
  mappings.forEach((map,i)=>{
    if(map.srcPoints.length<4 || map.tgtPoints.length<4) return;
    code+=`// Mapping ${i+1}\n`;
    code+=`const src${i}=${JSON.stringify(map.srcPoints)};\n`;
    code+=`const tgt${i}=${JSON.stringify(map.tgtPoints)};\n`;
  });
  code+=`
function mapPoint(x,y,mapping){
  const src=mapping.src, dst=mapping.dst;
  const u=(x-src[0][0])/(src[1][0]-src[0][0]||1);
  const v=(y-src[0][1])/(src[3][1]-src[0][1]||1);
  const X=dst[0][0]*(1-u)*(1-v)+dst[1][0]*u*(1-v)+dst[3][0]*(1-u)*v+dst[2][0]*u*v;
  const Y=dst[0][1]*(1-u)*(1-v)+dst[1][1]*u*(1-v)+dst[3][1]*(1-u)*v+dst[2][1]*u*v;
  return [X,Y];
}\n`;
  document.getElementById('jsCode').textContent = code;
});

</script>

</body>
</html>
