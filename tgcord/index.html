<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TGcord</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<style>
body { margin:0; font-family: Arial, Helvetica, sans-serif; background:#313338; color:#fff; }
.container { display:flex; height:100vh; }
.sidebar { width:240px; background:#2b2d31; padding:10px; overflow-y:auto; display:flex; flex-direction:column; }
.container {
    display: flex;
    height: 100vh;
    overflow: hidden; /* prevent scroll pushing sidebar down */
}

.chatArea {
    flex: 1 1 auto; /* grow and shrink as needed */
    display: flex;
    flex-direction: column;
    min-width: 0; /* allows inner flex children to shrink properly */
    overflow: hidden; /* prevent pushing right sidebar */
}

.messages {
    flex: 1 1 auto; /* grows to fill remaining space */
    padding: 15px;
    overflow-y: auto;
    min-height: 0; /* critical for flex scroll */
}

.rightSidebar {
    width: 260px;
    background: #232428;
    padding: 15px;
    border-left: 1px solid #444;
    display: flex;
    flex-direction: column;
    flex-shrink: 0; /* do not shrink */
    height: 100vh; /* ensure full height */
    overflow-y: auto;
}
.topbar { background:#232428; padding:12px; font-weight:bold; }
.messageInput { display:flex; padding:10px; background:#2b2d31; }
.messageInput input { flex:1; padding:10px; border:none; border-radius:6px; }
.messageInput button { margin-left:10px; padding:10px 15px; border:none; border-radius:6px; background:#5865f2; color:white; cursor:pointer; }
.userCard, .serverCard { padding:8px; margin:4px 0; background:#3f4147; border-radius:6px; cursor:pointer; }
.userCard:hover, .serverCard:hover { background:#4e5058; }
.avatar { width:32px; height:32px; border-radius:50%; vertical-align:middle; margin-right:8px; }
.hidden { display:none; }
.centered { padding:40px; }
input, button { padding:8px; margin:5px; }
button { background:#5865f2; border:none; border-radius:6px; color:white; cursor:pointer; }
button:hover { opacity:0.9; }
#ownUser { margin-top:auto; padding:8px; background:#2b2d31; text-align:center; border-top:1px solid #444; }
.toggleButtons { display:flex; justify-content:space-around; margin-bottom:5px; }
.toggleButtons button { flex:1; margin:2px; }
#logoutBtn {background:red;}
/* Discord-style messages */
.messageCard {
    display: flex;
    margin-bottom: 10px;
    align-items: flex-start;
}

.messageCard .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
    flex-shrink: 0;
}

.messageContent {
    display: flex;
    flex-direction: column;
}

.messageHeader {
    font-weight: bold;
    font-size: 0.9em;
    margin-bottom: 2px;
}

.messageHeader span.username {
    font-weight: normal;
    color: #b9bbbe;
    margin-left: 5px;
}

.messageText {
    word-wrap: break-word;
    font-size: 0.95em;
}
.messageSending {
    opacity: 0.5;
}
.avatarWrapper {
    position: relative;
    display: inline-block;
}

.statusDot {
    position: absolute;
    bottom: -2px;
    right: -2px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid #2b2d31;
}

.status-online { background: #23a559; }
.status-idle { background: #f0b232; }
.status-offline { background: #80848e; }


.profilePreviewAvatar {
    width:80px;
    height:80px;
    border-radius:50%;
    margin-bottom:10px;
}

.profileSection {
    margin-bottom:15px;
    font-size:0.9em;
    opacity:0.9;
}

.profileLabel {
    font-size:0.75em;
    opacity:0.6;
    margin-bottom:3px;
}
.messageText .spoiler {
    background-color: #555;
    color: #555;
    cursor: pointer;
}
.messageText .spoiler.revealed {
    color: inherit;
}
.messageText img, .messageText video {
    max-width: 250px;
    border-radius: 6px;
}
a {
    color: lightblue
}
.messageAttachments {
    display: flex;
    flex-direction: column;
    margin-top: 5px;
    gap: 5px;
}

.messageAttachments img,
.messageAttachments video,
.messageAttachments iframe {
    max-width: 250px;
    border-radius: 6px;
}
.messageAttachments .embedCard:hover {
    border-color: #5865f2;
}
</style>
</head>
<body>

<!-- AUTH VIEW -->
<div id="authView" class="centered">
<h2>TGcord</h2>
<button onclick="showLogin()">Login</button>
<button onclick="showSignup()">Sign Up</button>
<button onclick="download()">Download server</button>

<div id="loginView">
<h3>Login</h3>
<input type="file" id="fileInput"><br>
<!-- OR <input type="text" id="fileUrl" placeholder="Public URL to .tgcord"> -->
<br>
<input type="password" id="loginPassword" placeholder="Password"><br>
<input type="text" id="serverUrl" placeholder="enter server address (redstonemc.net)"><br>
<button onclick="login()">Login</button>
</div>

<div id="signupView" class="hidden">
<h3>Create Account</h3>
<input type="text" id="newName" placeholder="Username"><br>
<input type="text" id="newNick" placeholder="Nickname"><br>
<input type="text" id="newAbout" placeholder="About"><br>
<input type="text" id="newPfp" placeholder="Link to profile pic"><br>
<input type="password" id="newPassword" placeholder="Password"><br>
<input type="password" id="confirmPassword" placeholder="Confirm Password"><br>
<button onclick="createAccount()">Generate Account File</button>
</div>
</div>

<!-- APP VIEW -->
<div id="appView" class="hidden container">
<div class="sidebar">
    <div class="toggleButtons">
        <button id="dmToggle" onclick="showDMs()">DMs</button>
        <button id="serverToggle" onclick="showServers()">Servers</button>
    </div>

    <div id="userList"></div>
    <div id="serverList" class="hidden"></div>

    <div id="serverActions" class="hidden">
        <button onclick="createServer()">Create Server</button>
    </div>

    <div id="ownUser" class="hidden" onclick="openOwnProfile()">
        <div class="avatarWrapper">
            <img class="avatar" id="ownAvatar" src="">
            <span id="ownStatusDot" class="statusDot status-online"></span>
        </div>
        <span id="ownName"></span>
        <button id="logoutBtn" onclick="logout()">log out</button>
    </div>
</div>

<div class="chatArea">
<div class="topbar" id="chatHeader">Select a user or server</div>
<div class="messages" id="messages">Loading messages...</div>
<!-- Image preview above input -->
<div id="imageAttachmentPreview" style="
    display:none;
    position:relative;
    width:120px;
    height:120px;
    margin-bottom:5px;
">
    <img id="attachedImage" style="
        width:100%;
        height:100%;
        object-fit:cover;
        border-radius:6px;
    ">
    <button id="removeAttachmentBtn" style="
        position:absolute;
        top:2px;
        right:2px;
        background:red;
        color:white;
        border:none;
        border-radius:50%;
        width:20px;
        height:20px;
        cursor:pointer;
        font-weight:bold;
        line-height:16px;
        padding:0;
    ">Ã—</button>
</div>

<!-- Message input row -->
<div style="display:flex; align-items:center; gap:5px;">
    <button id="uploadImageBtn" type="button" style="
        padding:10px;
        border-radius:6px;
        border:none;
        background:#5865f2;
        color:white;
        cursor:pointer;
    ">ðŸ“Ž</button>
    <input type="text" id="messageInput" placeholder="Message" style="
        flex:1; 
        padding:10px; 
        border-radius:6px; 
        border:none;
    ">
    <button onclick="sendMessage()" style="
        padding:10px 15px; 
        border-radius:6px; 
        border:none; 
        background:#5865f2; 
        color:white; 
        cursor:pointer;
    ">Send</button>
    <input type="file" id="imageFileInput" accept="image/*" style="display:none;">
</div>
</div>
<div class="rightSidebar" id="rightSidebar">
    <div style="text-align:center;">
        <div class="avatarWrapper" style="display:inline-block;">
            <img id="profileAvatar" class="profilePreviewAvatar" src="">
            <span id="profileStatus" class="statusDot status-offline"></span>
        </div>
    </div>

    <div class="profileSection">
        <div class="profileLabel">DISPLAY NAME</div>
        <div id="profileDisplay"></div>
    </div>

    <div class="profileSection">
        <div class="profileLabel">USERNAME</div>
        <div id="profileUsername"></div>
    </div>

    <div class="profileSection">
        <div class="profileLabel">ABOUT</div>
        <div id="profileAbout"></div>
    </div>

    <div class="profileSection">
        <div class="profileLabel">CREATED</div>
        <div id="profileCreated"></div>
    </div>
</div>
</div>

<script>
let account=null, sessionId=null, serverBase=null;
let selectedUser=null, selectedServer=null, lastTimestamp=0, pollInterval=null;
let lastMessageTimestamp = 0; // tracks newest message we've seen
let firstMessageLoad = true; // used to suppress sound on initial load
let showDMList = true;
let sendingMessages = []; // array of {id, element}
const unreadMap = new Map(); // key: userId, value: boolean
const notifAudio = new Audio("https://tggamesyt.dev/assets/tgcord.mp3");
// Variables to store selected image and its direct URL
let attachedImageFile = null;
let attachedImageUrl = null;

// Elements
const uploadBtn = document.getElementById("uploadImageBtn");
const fileInput = document.getElementById("imageFileInput");
const previewDiv = document.getElementById("imageAttachmentPreview");
const attachedImgEl = document.getElementById("attachedImage");
const removeBtn = document.getElementById("removeAttachmentBtn");

// Open file picker
uploadBtn.addEventListener("click", () => {
    fileInput.value = "";
    fileInput.click();
});

// Handle file selection
fileInput.addEventListener("change", () => {
    if (!fileInput.files.length) return;
    attachedImageFile = fileInput.files[0];
    uploadAndPreview(attachedImageFile);
});

// Remove attachment
removeBtn.addEventListener("click", () => {
    attachedImageFile = null;
    attachedImageUrl = null;
    previewDiv.style.display = "none";
    attachedImgEl.src = "";
});

// Upload image to PostImages and show preview
async function uploadAndPreview(file) {
    previewDiv.style.display = "block";
    attachedImgEl.src = ""; // clear while uploading
    attachedImgEl.style.opacity = "0.5";

    const formData = new FormData();
    formData.append("gallery", "");
    formData.append("optsize", "0");
    formData.append("expire", "0");
    formData.append("numfiles", "1");
    formData.append("upload_session", Date.now() + "." + Math.random());
    formData.append("file", file);

    try {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", "https://postimages.org/json");
        xhr.setRequestHeader("Accept", "application/json");
        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");

        xhr.onload = async function () {
            if (xhr.status !== 200) {
                alert("Upload failed");
                return;
            }

            const resp = JSON.parse(xhr.responseText);
            let pageUrl = resp.url.split("/").slice(0, 4).join("/");

            // Use CORS proxy
            const proxyUrl = "https://proxy.corsfix.com?" + pageUrl;
            const pageResp = await fetch(proxyUrl);
            const html = await pageResp.text();

            const match = html.match(/https:\/\/i\.postimg\.cc\/[^\s"'<>]+/i);
            if (match) {
                attachedImageUrl = match[0];
                attachedImgEl.src = attachedImageUrl;
                attachedImgEl.style.opacity = "1";
            } else {
                alert("Direct URL not found");
                attachedImageUrl = null;
            }
        };
        xhr.send(formData);
    } catch (e) {
        console.error("Upload error", e);
        alert("Upload error");
    }
}

// Override sendMessage to append image URL
const originalSendMessage = sendMessage;
sendMessage = async function () {
    let msg = document.getElementById("messageInput").value.trim();
    if (!msg && !attachedImageUrl) return;

    // Append image URL if attached
    if (attachedImageUrl) {
        msg = msg ? msg + "\n" + attachedImageUrl : attachedImageUrl;
    }

    // Clear attachment
    attachedImageFile = null;
    attachedImageUrl = null;
    previewDiv.style.display = "none";
    attachedImgEl.src = "";

    // Put text into input temporarily to reuse existing sendMessage
    document.getElementById("messageInput").value = msg;
    await originalSendMessage();
};

/* ================== SERVER DETECT ================== */
async function detectServer(input){
    if(!input) input="redstonemc.net";
    input = input.trim();

    let urlsToTry = [];

    if(input.startsWith("http://") || input.startsWith("https://")){
        urlsToTry.push(input.replace(/\/+$/,""));
        if(input.startsWith("http://")) urlsToTry.push(input.replace(/^http:/,"https:"));
        else urlsToTry.push(input.replace(/^https:/,"http:"));
    } else {
        urlsToTry.push("https://" + input + ":21280");
        urlsToTry.push("http://" + input + ":21280");
    }

    for(let url of urlsToTry){
        try {
            const res = await fetch(url + "/status");
            if(res.ok){
                serverBase = url.replace(/\/+$/,"");
                console.log("Using server:", serverBase);
                return;
            }
        } catch(e){
            // failed, try next
        }
    }

    alert("Server not reachable at any protocol/port tried");
    throw new Error("No server reachable");
}


/* ================== CRYPTO ================== */

async function deriveKey(password, salt) {
    const enc = new TextEncoder();

    const keyMaterial = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        "PBKDF2",
        false,
        ["deriveKey"]
    );

    return crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt: salt,
            iterations: 150000,
            hash: "SHA-256"
        },
        keyMaterial,
        {
            name: "AES-GCM",
            length: 256
        },
        false,
        ["encrypt", "decrypt"]
    );
}

async function encryptAccount(account, password) {
    const enc = new TextEncoder();

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const key = await deriveKey(password, salt);

    const encrypted = await crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        key,
        enc.encode(JSON.stringify(account))
    );

    return {
        salt: btoa(String.fromCharCode(...salt)),
        iv: btoa(String.fromCharCode(...iv)),
        data: btoa(String.fromCharCode(...new Uint8Array(encrypted)))
    };
}

async function decryptAccount(raw, password) {
    const data = JSON.parse(raw);

    const salt = Uint8Array.from(
        atob(data.salt),
        c => c.charCodeAt(0)
    );

    const iv = Uint8Array.from(
        atob(data.iv),
        c => c.charCodeAt(0)
    );

    const encrypted = Uint8Array.from(
        atob(data.data),
        c => c.charCodeAt(0)
    );

    const key = await deriveKey(password, salt);

    const decrypted = await crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        key,
        encrypted
    );

    return JSON.parse(
        new TextDecoder().decode(decrypted)
    );
}


/* ================== AUTH ================== */

function showLogin() {
    document.getElementById("signupView").classList.add("hidden");
    document.getElementById("loginView").classList.remove("hidden");
}

function showSignup() {
    document.getElementById("loginView").classList.add("hidden");
    document.getElementById("signupView").classList.remove("hidden");
}

function download() {
    // 1. Open instructions page
    window.open(
        "https://tggamesyt.dev/tgcord/server-instructions.html",
        "_blank"
    );
}

async function createAccount() {
    const pfpInput = newPfp.value.trim();
    let pfp = null;

    // 1ï¸âƒ£ Check extension first
    if (pfpInput.match(/\.(jpeg|jpg|gif|png|webp)$/i)) {
        pfp = pfpInput;
    } else {
        pfp = null
        console.warn("Not a valid image URL by extension");
    }
    const pass = newPassword.value;
    const confirm = confirmPassword.value;
    const username = newName.value;
    const nick = newNick.value;
    const about = newAbout.value;
    if (pass !== confirm) {
        return alert("Passwords do not match");
    }

    if (!username) {
        return alert("Username required");
    }

    const acc = {
        id: crypto.randomUUID(),
        username: username,
        nickname: nick,
        about: about,
        avatar: pfp
    };

    const encrypted = await encryptAccount(acc, pass);

    const blob = new Blob(
        [JSON.stringify(encrypted)],
        { type: "application/json" }
    );

    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = username + ".tgcord";
    link.click();
}
async function login(){
    const file=fileInput.files[0];
    //const url=fileUrl.value;
    const pass=loginPassword.value;
    const serverInput=serverUrl.value;
    let raw;
    if(file) raw=await file.text();
    //else if(url) raw=await fetch(url).then(r=>r.text());
    else return alert("Provide account file");

    try{ account=await decryptAccount(raw,pass); } catch { return alert("Wrong password"); }

    await detectServer(serverInput);

    const res = await fetch(serverBase + "/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ encryptedAccount: raw, password: pass })
    });
    const data=await res.json();
    if(!data.success) return alert("Login failed: " + data?.error || "Unknown Error");
    
    sessionId = data.sessionId;
    startPresence(sessionId);
    // Save session in localStorage
    localStorage.setItem("tgcordSessionId", sessionId);
    localStorage.setItem("tgcordAccountId", account.id);
    localStorage.setItem("tgcordServerIp", serverBase);


    document.getElementById("authView").classList.add("hidden");
    document.getElementById("appView").classList.remove("hidden");

    document.getElementById("ownUser").classList.remove("hidden");
    document.getElementById("ownName").innerText = account.nickname || account.username;
    document.getElementById("ownAvatar").src = getavatarlink(account)
    showDMs();
    pollInterval = setInterval(fetchMessages,3000);
}

let presenceInterval;

function startPresence(sessionId) {
    function send(status) {
        fetch(serverBase + "/presence", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sessionId, status })
        });

        const dot = document.getElementById("ownStatusDot");
        if (dot) {
            dot.className = "statusDot status-" + status;
        }
    }

    presenceInterval = setInterval(() => {
        const status = document.hidden ? "idle" : "online";
        send(status);
    }, 20000);

    send("online");
}

/* ================== USERS ================== */
async function showDMs(){
    showDMList = true;
    document.getElementById("userList").classList.remove("hidden");
    document.getElementById("serverList").classList.add("hidden");
    document.getElementById("serverActions").classList.add("hidden");
    await loadUsers();

    // Auto-select the first DM if it exists
    const firstUserCard = document.getElementById("userList").firstChild;
    if(firstUserCard) {
        firstUserCard.click();
    }
}


async function showServers(){
    showDMList = false;
    document.getElementById("userList").classList.add("hidden");
    document.getElementById("serverList").classList.remove("hidden");
    await loadServers();
}

async function loadUsers(){
    const res = await fetch(serverBase+"/users");
    let users = await res.json();
    users = users.filter(u => u.id !== account.id);

    const list = document.getElementById("userList");
    list.innerHTML = "";

    users.forEach(u => {
        const div = document.createElement("div");
        div.className = "userCard";
        div.dataset.userid = u.id;

        const avatar = getavatarlink(u)

        div.innerHTML = `
            <div class="avatarWrapper">
                <img class="avatar" src="${avatar}">
                <span class="statusDot status-${u.status || "offline"}"></span>
                <span class="unreadBadge hidden"
                    style="position:absolute;top:0;right:0;width:10px;height:10px;background:red;border-radius:50%;">
                </span>
            </div>
            ${u.nickname || u.username}
        `;

        div.onclick = () => selectUser(u);
        list.appendChild(div);
    });
}

async function loadServers(){
    const res = await fetch(serverBase+"/servers");
    let servers = await res.json();
    const list = document.getElementById("serverList");
    list.innerHTML = "";

    servers.forEach(s=>{
        const div = document.createElement("div");
        div.className = "serverCard";
        div.innerText = s.name;
        div.onclick = () => openServer(s);
        list.appendChild(div);
    });

    // Show create server button if allowed
    const actions = document.getElementById("serverActions");
    actions.classList.toggle("hidden", !account.canCreateServer);
}

/* ================== SELECT ================== */
function selectUser(user){
    selectedUser = user;
    selectedServer = null;

    document.getElementById("chatHeader").innerText =
        user.nickname || user.username;

    document.getElementById("messages").innerHTML =
        '<div style="opacity:0.5; text-align:center;">Loading messages...</div>';

    lastTimestamp = 0;

    unreadMap.set(user.id, false);
    clearUnreadBadge(user.id);

    showProfileOnRight(user); // ðŸ‘ˆ NEW
}

/* ================== SERVER ================== */
function openServer(server){
    selectedServer=server;
    selectedUser=null;
    document.getElementById("chatHeader").innerText = "Server: "+server.name;
    document.getElementById("messages").innerHTML="Channels will be listed here...";
}

/* ================== MESSAGES ================== */
async function sendMessage() {
    if (!showDMList) {
        alert("Server messaging not yet implemented");
        return;
    }

    if (!selectedUser) return alert("Select user");
    const msg = messageInput.value.trim();
    if (!msg) return;

    const tempId = crypto.randomUUID();

    // Create temporary "sending" message
    const sendingMsg = {
        from: account.id,
        message: msg,
        tempId,
        timestamp: new Date().getTime()
    };

    const elem = await addMessage(sendingMsg, [account], true);
    sendingMessages.push({ tempId, element: elem, message: msg });

    messageInput.value = "";

    try {
        await fetch(serverBase + "/dm", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sessionId, to: selectedUser.id, message: msg })
        });
    } catch (e) {
        console.error("Failed to send message:", e);
    }

    // Fetch messages immediately to replace placeholder
    await fetchMessages();
}
async function fetchMessages() {
    if (!selectedUser) return; 

    const messagesDiv = document.getElementById("messages");

    // Show loading if first load
    if (firstMessageLoad) {
        messagesDiv.innerHTML = '<div style="opacity:0.5; text-align:center;">Loading messages...</div>';
    }

    const res = await fetch(
        serverBase +
        "/messages?since=" + lastTimestamp +
        "&sessionId=" + sessionId +
        "&with=" + selectedUser.id
    ); 

    const msgs = await res.json(); 
    const usersRes = await fetch(serverBase + "/users");
    const allUsers = await usersRes.json();

    // Clear loading placeholder
    if (firstMessageLoad) messagesDiv.innerHTML = "";

    // Filter messages: show only
    // 1) From selectedUser to you
    // 2) From you to selectedUser
    const filteredMsgs = msgs.filter(m => 
        (m.from === selectedUser.id && m.to === account.id) || 
        (m.from === account.id && m.to === selectedUser.id)
    );

    filteredMsgs.forEach(m => {
    // Remove placeholder if sending
    if (m.from === account.id) {
        const index = sendingMessages.findIndex(s => s.message === m.message);
        if (index !== -1) {
            sendingMessages[index].element.remove(); 
            sendingMessages.splice(index, 1);
        }
    }

    // Filter to only show messages with selectedUser
    if (selectedUser && ((m.from === selectedUser.id && m.to === account.id) || (m.from === account.id && m.to === selectedUser.id))) {
        addMessage(m, allUsers);

        // Play notification only for incoming messages from selectedUser
        if (!firstMessageLoad && m.from === selectedUser.id) notifAudio.play().catch(() => {});
    }

    // Handle unread badge for messages from others
    if (m.from !== account.id && (!selectedUser || m.from !== selectedUser.id)) {
        unreadMap.set(m.from, true);
        showUnreadBadge(m.from);
    }

    if (m.timestamp > lastTimestamp) lastTimestamp = m.timestamp;
    if (m.timestamp > lastMessageTimestamp) lastMessageTimestamp = m.timestamp;
});


    if (firstMessageLoad) firstMessageLoad = false;
    if (showDMList) {
        loadUsers(); // refresh statuses
    }
}

function formatSmartTimestamp(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();

    const isToday =
        date.getFullYear() === now.getFullYear() &&
        date.getMonth() === now.getMonth() &&
        date.getDate() === now.getDate();

    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);

    const isYesterday =
        date.getFullYear() === yesterday.getFullYear() &&
        date.getMonth() === yesterday.getMonth() &&
        date.getDate() === yesterday.getDate();

    const timeString = date.toLocaleTimeString([], {
        hour: "numeric",
        minute: "2-digit"
    });

    if (isToday) {
        return timeString;
    }

    if (isYesterday) {
        return `Yesterday at ${timeString}`;
    }

    return date.toLocaleString([], {
        month: "numeric",
        day: "numeric",
        year: "numeric",
        hour: "numeric",
        minute: "2-digit"
    });
}
function sanitize(str) {
    const temp = document.createElement('div');
    temp.textContent = str;
    return temp.innerHTML;
}
function createAvatar(avatarUrl) {
    const img = document.createElement("img");
    img.className = "avatar";
    img.src = avatarUrl;
    return img;
}
function getavatarlink(account) {
    return (account.avatar && account.avatar.match(/\.(jpeg|jpg|gif|png|webp)$/i)) 
        ? account.avatar 
        : 'https://api.dicebear.com/9.x/initials/svg?seed=' + encodeURIComponent(account.nickname || account.username);
    }
async function createWebsiteEmbed(url) {
    if (url.endsWith(")")) {
        url = url.slice(0, -1); // remove last character
    }
    try {
        const res = await fetch(`https://api.microlink.io/?url=${encodeURIComponent(url)}`);
        const data = await res.json();
        if (!data.status || !data.data) return null;

        const card = document.createElement("a");
        card.href = url;
        card.target = "_blank";
        card.className = "embedCard";

        card.style.display = "flex";
        card.style.flexDirection = "row";
        card.style.border = "1px solid #444";
        card.style.borderRadius = "8px";
        card.style.padding = "8px";
        card.style.marginTop = "5px";
        card.style.textDecoration = "none";
        card.style.color = "#fff";
        card.style.maxWidth = "250px";

        const thumbnail = document.createElement("img");
        thumbnail.src = data.data.image?.url || '';
        thumbnail.style.width = "60px";
        thumbnail.style.height = "60px";
        thumbnail.style.objectFit = "cover";
        thumbnail.style.borderRadius = "4px";
        thumbnail.style.marginRight = "8px";

        const info = document.createElement("div");
        info.style.display = "flex";
        info.style.flexDirection = "column";
        info.style.justifyContent = "center";

        const title = document.createElement("div");
        title.innerText = data.data.title || url;
        title.style.fontWeight = "bold";
        title.style.fontSize = "0.85em";
        title.style.marginBottom = "2px";

        const desc = document.createElement("div");
        desc.innerText = data.data.description || "";
        desc.style.fontSize = "0.75em";
        desc.style.opacity = "0.8";

        info.appendChild(title);
        info.appendChild(desc);

        card.appendChild(thumbnail);
        card.appendChild(info);

        return card;
    } catch (e) {
        console.error("Embed fetch failed", e);
        return null;
    }
}
async function extractAttachments(text) {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    const urls = text.match(urlRegex) || [];
    let remainingText = text;
    const attachments = [];

    for (const url of urls) {
        let el = null;
        let removeFromText = false;

        if (url.match(/\.(jpeg|jpg|gif|png|webp)$/i)) {
            el = document.createElement("img");
            el.src = url;
            removeFromText = true; // remove image URLs from message
        } else if (url.match(/\.(mp4|webm|ogg)$/i)) {
            el = document.createElement("video");
            el.src = url;
            el.controls = true;
            removeFromText = true; // remove video URLs from message
        } else if (url.match(/youtube\.com\/watch\?v=([^\s&]+)/) || url.match(/youtu\.be\/([^\s&]+)/)) {
            const iframe = document.createElement("iframe");
            iframe.src = url.replace("watch?v=", "embed/");
            iframe.width = "250";
            iframe.height = "150";
            iframe.frameBorder = "0";
            iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
            iframe.allowFullscreen = true;
            el = iframe;
            removeFromText = true; // optional: remove YouTube link from message text
        } else {
            // Generic website embed: fetch metadata
            el = await createWebsiteEmbed(url);
            removeFromText = false; // keep generic website URLs in text
        }

        if (el) {
            el.style.display = "block";
            el.style.marginTop = "5px";
            el.style.maxWidth = "250px";
            el.style.borderRadius = "6px";
            attachments.push(el);
        }

        if (removeFromText) {
            remainingText = remainingText.replace(url, '').trim();
        }
    }

    return { remainingText, attachments };
}
async function addMessage(msg, allUsers, sending = false) {
    const sender = allUsers.find(u => u.id === msg.from);
    const displayName = sender ? sender.nickname : msg.from;
    const username = sender ? sender.username : msg.from;
    const avatar = getavatarlink(sender);

    const container = document.createElement("div");
    container.className = "messageCard";
    if (sending) container.classList.add("messageSending");

    const contentDiv = document.createElement("div");
    contentDiv.className = "messageContent";

    // Header
    const header = document.createElement("div");
    header.className = "messageHeader";
    header.innerHTML = `${displayName} <span class="username">(${username}) ${formatSmartTimestamp(msg.timestamp)}</span>`;
    contentDiv.appendChild(header);

    // Message text + attachments
    const textDiv = document.createElement("div");
    textDiv.className = "messageText";

    // âœ… Await extractAttachments
    const { remainingText, attachments } = await extractAttachments(msg.message);

    textDiv.innerHTML = marked.parseInline(sanitize(remainingText));
    contentDiv.appendChild(textDiv);

    // Attachments container
    const attachmentsDiv = document.createElement("div");
    attachmentsDiv.className = "messageAttachments";
    attachments.forEach(att => attachmentsDiv.appendChild(att));
    contentDiv.appendChild(attachmentsDiv);

    container.appendChild(createAvatar(avatar));
    container.appendChild(contentDiv);

    const messagesDiv = document.getElementById("messages");
    messagesDiv.appendChild(container);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

    return container;
}

function logout() {
    localStorage.removeItem("tgcordSessionId");
    localStorage.removeItem("tgcordAccountId");
    localStorage.removeItem("tgcordServerIp");
    location.reload();
}
function showUnreadBadge(userId) {
    const userList = document.getElementById("userList").children;
    for (let card of userList) {
        const img = card.querySelector(".avatar");
        if (!img) continue;
        const span = card.querySelector(".unreadBadge");
        if (!span) continue;
        // match by userId (we can attach it to dataset)
        if (card.dataset.userid === userId) {
            span.classList.remove("hidden");
        }
    }
}

function clearUnreadBadge(userId) {
    const userList = document.getElementById("userList").children;
    for (let card of userList) {
        const span = card.querySelector(".unreadBadge");
        if (card.dataset.userid === userId) {
            span.classList.add("hidden");
        }
    }
}
async function downloadUpdatedAccount(){
    const password = prompt("Enter your password to re-encrypt:");

    if(!password) return;

    const encrypted = await encryptAccount(account, password);

    const blob = new Blob(
        [JSON.stringify(encrypted)],
        { type: "application/json" }
    );

    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = account.username + ".tgcord";
    link.click();
}
function saveProfileChanges(){
    account.nickname = document.getElementById("editNick").value;
    account.about = document.getElementById("editAbout").value;
    account.avatar = document.getElementById("editAvatar").value;

    document.getElementById("ownName").innerText =
        account.nickname || account.username;

    document.getElementById("ownAvatar").src = getavatarlink(account)

    showProfileOnRight(account);
}
function openOwnProfile(){
    selectedUser = null;
    selectedServer = null;

    document.getElementById("chatHeader").innerText =
        "Edit Your Profile";

    document.getElementById("messages").innerHTML = `
        <div style="padding:20px;">
            <label>Nickname</label><br>
            <input id="editNick" value="${account.nickname || ''}"><br><br>

            <label>About</label><br>
            <input id="editAbout" value="${account.about || ''}"><br><br>

            <label>Avatar URL</label><br>
            <input id="editAvatar" value="${account.avatar || ''}"><br><br>

            <button onclick="saveProfileChanges()">Save Changes</button>
            <button onclick="downloadUpdatedAccount()">Download .tgcord</button>
        </div>
    `;

    showProfileOnRight(account); // preview
}
function showProfileOnRight(user) {
    document.getElementById("profileDisplay").innerText =
        user.nickname || user.username;

    document.getElementById("profileUsername").innerText =
        user.username;

    document.getElementById("profileAbout").innerText =
        user.about || "No bio yet.";

    document.getElementById("profileAvatar").src =
        getavatarlink(user)

    document.getElementById("profileStatus").className =
        "statusDot status-" + (user.status || "offline");

    // creation date from UUID timestamp not possible
    // so fallback if server sends createdAt
    document.getElementById("profileCreated").innerText =
        user.created
            ? formatSmartTimestamp(user.created)
            : "Unknown";
}

/* ================== CREATE SERVER ================== */
async function createServer(){
    const name = prompt("Server Name:");
    if(!name) return;
    await fetch(serverBase+"/create-server", { method:"POST", headers:{ "Content-Type":"application/json"}, body:JSON.stringify({ sessionId, name }) });
    await loadServers();
}

// Login inputs
["fileInput","loginPassword","serverUrl"].forEach(id => {
    document.getElementById(id).addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            login();
        }
    });
});

// Signup inputs
["newName","newNick","newAbout","newPassword","confirmPassword"].forEach(id => {
    document.getElementById(id).addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            createAccount();
        }
    });
});
document.getElementById("messageInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) { // Enter sends, Shift+Enter for newline
        e.preventDefault();
        sendMessage();
    }
});

window.addEventListener("load", async () => {
    serverBase = localStorage.getItem("tgcordServerIp");
    const storedSession = localStorage.getItem("tgcordSessionId");
    const storedAccountId = localStorage.getItem("tgcordAccountId");

    if (storedSession && storedAccountId && serverBase) {
        // Try to restore session
        sessionId = storedSession;
        startPresence(sessionId);
        // Fetch account info from server
        try {
            const res = await fetch(`${serverBase}/profile/${storedAccountId}`);
            if (res.ok) {
                account = await res.json();

                // Show app view
                document.getElementById("authView").classList.add("hidden");
                document.getElementById("appView").classList.remove("hidden");

                document.getElementById("ownUser").classList.remove("hidden");
                document.getElementById("ownName").innerText = account.nickname || account.username;
                document.getElementById("ownAvatar").src = getavatarlink(account)

                showDMs();
                pollInterval = setInterval(fetchMessages, 3000);
            } else {
                console.log("Session expired or invalid, need login");
                localStorage.removeItem("tgcordSessionId");
                localStorage.removeItem("tgcordAccountId");
                localStorage.removeItem("tgcordServerIp");
            }
        } catch (e) {
            console.error("Failed to restore session", e);
        }
    }
});

document.addEventListener("visibilitychange", () => {
    const status = document.hidden ? "idle" : "online";

    fetch(serverBase + "/presence", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            sessionId,
            status
        })
    });
    const dot = document.getElementById("ownStatusDot");
        if (dot) {
            dot.className = "statusDot status-" + status;
        }
});

let eCount = 0;
let eSoundPlayedCount = 0;
let jumpScareDone = false;
let eHeld = false;

const eeSound = new Audio("https://tggamesyt.dev/assets/ee.mp3");

let overlay = null;
let eLetter = null;
let jumpImage = null;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let eSource, eGain, eDist, ePitchLFO, eLfoGain;
let eBuffer = null;
let ePlaying = false;
let isDeepFried = false; // NEW

// load e.mp3 into buffer
fetch("https://tggamesyt.dev/assets/e.mp3")
  .then(r => r.arrayBuffer())
  .then(d => audioCtx.decodeAudioData(d))
  .then(buf => { eBuffer = buf; });

// load e.mp3 into buffer
fetch("https://tggamesyt.dev/assets/e.mp3")
  .then(r => r.arrayBuffer())
  .then(d => audioCtx.decodeAudioData(d))
  .then(buf => { eBuffer = buf; });

// helper: create distortion curve
function makeDistortionCurve(amount = 50) {
    const n = 44100, curve = new Float32Array(n);
    const deg = Math.PI / 180;
    for (let i = 0; i < n; ++i) {
        const x = i * 2 / n - 1;
        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

// start E sound
function playDeepFriedE() {
    if (!eBuffer || ePlaying) return;
    ePlaying = true;
    isDeepFried = false;

    eSource = audioCtx.createBufferSource();
    eSource.buffer = eBuffer;
    eSource.loop = true;

    eGain = audioCtx.createGain();
    eGain.gain.value = 0.5;

    // NO distortion yet
    eSource.connect(eGain).connect(audioCtx.destination);
    eSource.start();
}
function enableDeepFry() {
    if (!ePlaying || isDeepFried) return;
    isDeepFried = true;

    // disconnect clean chain
    eSource.disconnect();
    eGain.disconnect();

    eDist = audioCtx.createWaveShaper();
    eDist.curve = makeDistortionCurve(0);

    ePitchLFO = audioCtx.createOscillator();
    eLfoGain = audioCtx.createGain();
    eLfoGain.gain.value = 0;

    ePitchLFO.connect(eLfoGain);
    eLfoGain.connect(eSource.playbackRate);
    ePitchLFO.start();

    eSource.connect(eDist).connect(eGain).connect(audioCtx.destination);
}

// update distortion over time
function updateDeepFry(progress) {
    if (!ePlaying) return;
    if (eDist) eDist.curve = makeDistortionCurve(progress * 1000);
    if (ePitchLFO) ePitchLFO.frequency.value = 2 + progress * 8;
    if (eLfoGain) eLfoGain.gain.value = progress * 0.2;
}

// stop E sound
function stopDeepFriedE() {
    if (!ePlaying) return;
    ePlaying = false;
    if (eSource) { eSource.stop(); eSource.disconnect(); eSource = null; }
    if (eDist) { eDist.disconnect(); eDist = null; }
    if (eGain) { eGain.disconnect(); eGain = null; }
    if (ePitchLFO) { ePitchLFO.disconnect(); ePitchLFO = null; }
    if (eLfoGain) { eLfoGain.disconnect(); eLfoGain = null; }
}


function createOverlay() {
    if (!overlay) {
        overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.top = 0;
        overlay.style.left = 0;
        overlay.style.width = "100vw";
        overlay.style.height = "100vh";
        overlay.style.background = "rgba(0,0,0,0)";
        overlay.style.display = "flex";
        overlay.style.justifyContent = "center";
        overlay.style.alignItems = "center";
        overlay.style.transition = "background 0.3s ease";
        overlay.style.zIndex = 9999;
        document.body.appendChild(overlay);
    }

    if (!eLetter) {
        eLetter = document.createElement("div");
        eLetter.innerText = "E";
        eLetter.style.fontSize = "50px";
        eLetter.style.color = "white";
        eLetter.style.transition = "transform 0.3s ease, opacity 0.3s ease";
        eLetter.style.opacity = "0";
        overlay.appendChild(eLetter);
    }

    if (!jumpImage) {
        jumpImage = document.createElement("img");
        jumpImage.src = "https://tggamesyt.dev/assets/ee.png";
        jumpImage.style.position = "fixed";
        jumpImage.style.top = "50%";
        jumpImage.style.left = "50%";
        jumpImage.style.transform = "translate(-50%, -50%) scale(0)";
        jumpImage.style.transition = "transform 0.5s ease";
        jumpImage.style.zIndex = 10000;
        document.body.appendChild(jumpImage);
    }
}

function resetE() {
    eCount = 0;
    eSoundPlayedCount = 0;
    jumpScareDone = false;
    eHeld = false;

    if (overlay) overlay.style.background = "rgba(0,0,0,0)";
    if (eLetter) {
        eLetter.style.transform = "scale(1)";
        eLetter.style.opacity = "0";
    }
    if (jumpImage) jumpImage.style.transform = "translate(-50%, -50%) scale(0)";
}

function updateVisuals() {
    if (eCount < 250 || !eHeld) {
        if (overlay) overlay.style.background = "rgba(0,0,0,0)";
        if (eLetter) eLetter.style.opacity = "0";
        return;
    }

    // overlay darkening and reddening
    if (overlay) {
        const darkProgress = Math.min((eCount - 250) / 600, 0.6); 
        const redProgress = Math.max(0, (eCount - 600) / 250);
        overlay.style.background = `rgba(${redProgress*255},0,0,${darkProgress})`;
    }

    // E grows
    if (eLetter) {
        const minScale = 0.4; // start smaller
        const maxScale = 15;   // end larger
        const progress = Math.min((eCount - 250)/600, 1);
        const scale = minScale + (maxScale - minScale) * progress;

        eLetter.style.opacity = "1";
        eLetter.style.transform = `scale(${scale})`;

        // shake when red starts
        if (eCount > 600) {
            const intensity = Math.min((eCount - 600) / 250, 1) * 10;
            const x = (Math.random() - 0.5) * intensity;
            const y = (Math.random() - 0.5) * intensity;
            eLetter.style.transform += ` translate(${x}px, ${y}px)`;
        }
    }
}

function maybePlayESound() {

    // start normal sound after 150
    if (eCount >= 150 && !jumpScareDone && !ePlaying) {
        playDeepFriedE();
    }

    // DO NOT deep fry until 700
    if (eCount >= 700 && ePlaying) {
        enableDeepFry();

        const progress = Math.min((eCount - 700) / 300, 1);
        updateDeepFry(progress);
    }

    if (eCount >= 950 && !jumpScareDone) {
        jumpScareDone = true;
        eeSound.play().catch(() => {});
        if (jumpImage) jumpImage.style.transform =
            "translate(-50%, -50%) scale(4)";
    }
}


document.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "e") {
        if (!eHeld) {
            eHeld = true;
            createOverlay();
        }

        eCount++;
        updateVisuals();
        maybePlayESound();
    }
});

document.addEventListener("keyup", (e) => {
    if (e.key.toLowerCase() === "e") {
        resetE(); // everything gone immediately on release
        stopDeepFriedE();
    }
});


let rickRollBuffer = "";
let rickRollPlayed = false;
const RICK_ROLL_PHRASE = "rick roll";

// Listen globally
window.addEventListener("keydown", (e) => {
    // Ignore modifier keys
    if (e.key.length > 1) return;

    // Add the key to buffer (lowercase)
    rickRollBuffer += e.key.toLowerCase();

    // Keep buffer length reasonable
    if (rickRollBuffer.length > 50) {
        rickRollBuffer = rickRollBuffer.slice(-50);
    }

    // Check if buffer contains the phrase
    if (!rickRollPlayed && rickRollBuffer.includes(RICK_ROLL_PHRASE)) {
        rickRollPlayed = true;
        playRickRoll();
    }
});

function playRickRoll() {
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = 0;
    overlay.style.left = 0;
    overlay.style.width = "100vw";
    overlay.style.height = "100vh";
    overlay.style.background = "rgba(0,0,0,0.8)";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";
    overlay.style.zIndex = 9999;

    const iframe = document.createElement("iframe");
    iframe.src = "https://www.youtube.com/embed/dQw4w9WgXcQ?autoplay=1";
    iframe.width = "560";
    iframe.height = "315";
    iframe.frameBorder = "0";
    iframe.allow = "autoplay; encrypted-media; picture-in-picture";
    iframe.allowFullscreen = true;
    iframe.style.borderRadius = "8px";

    overlay.appendChild(iframe);
    document.body.appendChild(overlay);

    // Remove overlay on click
    overlay.addEventListener("click", () => {
        overlay.remove();
        rickRollPlayed = false;
        rickRollBuffer = ""; // reset buffer so it can trigger again
    });
}

</script>
</body>
</html>
