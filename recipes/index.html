<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minecraft Recipe Browser (offline JEI)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" crossorigin="anonymous"></script>
  <style>
    :root{--bg:#0b0f14;--card:#0f1720;--muted:#9aa6b2;--accent:#6ee7b7}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071021 0%, #0b1622 100%);color:#e6eef6;padding:18px}
    .app{max-width:1140px;margin:0 auto}
    header{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    h1{margin:0;font-size:20px}
    .uploader{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
    .drop{flex:1;min-width:280px;border:2px dashed rgba(255,255,255,0.06);padding:16px;border-radius:8px;background:rgba(255,255,255,0.01)}
    .btn{background:var(--accent);color:#042018;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    .two{display:grid;grid-template-columns:320px 1fr;gap:12px;margin-top:12px}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px}
    .list{max-height:64vh;overflow:auto}
    .recipe-item{padding:8px;border-radius:6px;margin-bottom:6px;cursor:pointer}
    .recipe-item:hover{background:rgba(255,255,255,0.02)}
    .grid{display:grid;grid-template-columns:repeat(3,64px);gap:6px}
    .slot{width:64px;height:64px;border-radius:6px;background:#071021;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.03);position:relative}
    .slot img{max-width:54px;max-height:54px}
    .title{font-weight:600}
    input[type=search], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    .meta{color:var(--muted);font-size:13px}
    .note{color:var(--muted);font-size:13px;margin-top:8px}
    .small{font-size:13px;color:var(--muted)}
    pre{white-space:pre-wrap;word-break:break-word}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Minecraft Recipe Browser</h1>
      <div class="small">Upload jars manually or fetch vanilla client via Mojang Piston meta</div>
    </header>

    <div class="uploader">
      <div class="drop panel" id="drop">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <strong>Drop one or more .jar/.zip files</strong>
            <div class="meta">vanilla jars, mod jars (Forge/Fabric), resourcepacks</div>
          </div>
          <div>
            <label class="btn">Choose files<input id="fileInput" type="file" accept=".jar,.zip" multiple style="display:none"></label>
          </div>
        </div>
        <div class="note">Scans <code>data/*/recipes/</code> and <code>data/*/recipe/</code>, loads textures/lang when found.</div>
      </div>

      <div style="width:280px;display:flex;flex-direction:column;gap:8px">
        <button class="btn" id="exportBtn">Export recipes JSON</button>
        <div class="panel small" id="stats">No files loaded</div>
        <div class="panel small">
          <div><strong>Fetch vanilla client jar</strong></div>
          <select id="versionSelect"></select>
          <button class="btn" id="downloadBtn">Download & Load</button>
          <div class="note">Uses Mojang's official Piston meta + client jar</div>
        </div>
      </div>
    </div>

    <div class="two">
      <div class="panel">
        <input id="search" type="search" placeholder="Search recipes or items..." />
        <div class="list" id="recipeList"></div>
      </div>

      <div class="panel" id="viewer">
        <div id="viewerInner"><div class="meta">Select a recipe to view details</div></div>
      </div>
    </div>
  </div>
<script>
(async function() {
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const recipeList = document.getElementById('recipeList');
  const viewer = document.getElementById('viewerInner');
  const stats = document.getElementById('stats');
  const exportBtn = document.getElementById('exportBtn');
  const search = document.getElementById('search');
  const versionSelect = document.getElementById('versionSelect');
  const downloadBtn = document.getElementById('downloadBtn');

  const state = {
    files: [],
    recipes: [],
    assets: {},
    langs: {},
    models: {},
    versionMeta: null,
    textureCache: {},
    assetBlobCache: {}
  };

  function setStats() {
    stats.innerHTML = `${state.files.length} files • ${state.recipes.length} recipes • ${Object.keys(state.assets).length} assets`;
  }

  async function handleFiles(fileList) {
    recipeList.innerHTML = '<div class="meta">Scanning...</div>';
    for (const f of fileList) {
      try {
        const buff = await f.arrayBuffer();
        const zip = await JSZip.loadAsync(buff);
        state.files.push({ name: f.name, zip, raw: f });

        for (const path in zip.files) {
          const entry = zip.files[path];
          if (entry.dir) continue;
          const normalized = path.replace(/\\/g, '/');

          // Recipes
          if (/^data\/[^\/]+\/(recipes|recipe)\/.*\.json$/.test(normalized)) {
            try {
              const jsonText = await entry.async('string');
              const json = JSON.parse(jsonText);
              const match = normalized.match(/^data\/([^\/]+)\/(recipes|recipe)\/(.+)\.json$/);
              const namespace = match[1];
              const recipePath = match[3];
              const id = namespace + ':' + recipePath;

              let ingredients = [], result = null;

              // gather ingredients and result
              const collect = (o) => {
                if (!o || typeof o !== 'object') return;
                for (const k in o) {
                  if (k === 'item' && typeof o[k] === 'string') ingredients.push(o[k]);
                  else if (typeof o[k] === 'object') collect(o[k]);
                  else if (Array.isArray(o[k])) o[k].forEach(collect);
                }
              };
              try {
                if (json.key || json.pattern) {
                  Object.values(json.key || {}).forEach(val => {
                    if (!val) return;
                    if (typeof val === 'string') ingredients.push(val);
                    if (val.item) ingredients.push(val.item);
                    if (val.tag) ingredients.push(val.tag);
                    if (Array.isArray(val)) val.forEach(v => v.item && ingredients.push(v.item));
                  });
                  result = (json.result && (json.result.item || json.result)) || null;
                } else if (json.ingredients) {
                  json.ingredients.forEach(val => {
                    if (!val) return;
                    if (val.item) ingredients.push(val.item);
                    else if (val.tag) ingredients.push(val.tag);
                    else if (typeof val === 'string') ingredients.push(val);
                    else if (Array.isArray(val)) val.forEach(v => v.item && ingredients.push(v.item));
                  });
                  result = (json.result && (json.result.item || json.result)) || null;
                } else collect(json);
              } catch (e) { }

              state.recipes.push({ id, namespace, path: recipePath, json, source: f.name, ingredients: ingredients.filter(Boolean), result });
            } catch (e) { console.warn('bad recipe', normalized, e); }
          }

          // Assets
          if (/^assets\/[^\/]+\/textures\/.*\.(png|jpg|jpeg)$/i.test(normalized)) {
            const key = normalized.replace(/^assets\//, '');
            state.assets[key] = state.assets[key] || [];
            state.assets[key].push({ file: f.name, entry });
          }

          // Models
          if (/^assets\/[^\/]+\/models\/.*\.json$/i.test(normalized)) {
            try {
              const txt = await entry.async('string');
              const j = JSON.parse(txt);
              const key = normalized.replace(/^assets\//, '');
              state.models[key] = j;
            } catch (e) { console.warn('model parse', normalized, e); }
          }

          // Langs
          if (/^assets\/[^\/]+\/lang\/.*\.(json|lang)$/i.test(normalized)) {
            const match = normalized.match(/^assets\/([^\/]+)\/lang\/([^\/]+)\.(json|lang)$/i);
            if (match) {
              const locale = match[2];
              const ext = match[3];
              try {
                const txt = await entry.async('string');
                state.langs[locale] = state.langs[locale] || {};
                if (ext.toLowerCase() === 'json') Object.assign(state.langs[locale], JSON.parse(txt));
                else txt.split(/\r?\n/).forEach(line => {
                  if (!line || line.startsWith('#')) return;
                  const idx = line.indexOf('=');
                  if (idx > 0) state.langs[locale][line.slice(0, idx).trim()] = line.slice(idx + 1).trim();
                });
              } catch (e) { console.warn('lang parse', normalized, e); }
            }
          }
        }
      } catch (e) {
        console.error('Failed to read file', f.name, e);
      }
    }
    setStats();
    buildRecipeIndex();
    renderRecipeList();
  }

  function buildRecipeIndex() {
    for (const r of state.recipes) {
      r._searchText = (r.id || '') + ' ';
      if (r.result) r._searchText += r.result + ' ';
      if (r.ingredients) r._searchText += r.ingredients.join(' ') + ' ';
      r._searchText = r._searchText.toLowerCase();
    }
  }

  function matchesSearch(r, q) {
    q = q.trim().toLowerCase();
    if (!q) return true;
    if (r._searchText && r._searchText.includes(q)) return true;
    try { if (JSON.stringify(r.json).toLowerCase().includes(q)) return true; } catch (e) { }
    return false;
  }

  async function entryBlobURL(entry) {
    try {
      const arr = await entry.async('arraybuffer');
      return URL.createObjectURL(new Blob([arr]));
    } catch (e) { console.warn('entryBlobURL failed', e); return null; }
  }

  async function getAssetBlobURLByKey(key) {
    if (state.assetBlobCache[key]) return state.assetBlobCache[key];
    const arr = state.assets[key];
    if (!arr || !arr.length) return null;
    const url = await entryBlobURL(arr[0].entry);
    state.assetBlobCache[key] = url;
    return url;
  }

  function escapeHtml(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Basic event wiring
  drop.addEventListener('dragover', e => e.preventDefault());
  drop.addEventListener('drop', e => {
    e.preventDefault();
    const files = [...e.dataTransfer.files].filter(f => f.name.endsWith('.jar') || f.name.endsWith('.zip'));
    if (files.length) handleFiles(files);
  });
  fileInput.addEventListener('change', e => {
    const files = [...e.target.files].filter(f => f.name.endsWith('.jar') || f.name.endsWith('.zip'));
    if (files.length) handleFiles(files);
  });
  search.addEventListener('input', renderRecipeList);
  exportBtn.addEventListener('click', () => {
    const out = state.recipes.map(r => ({ id: r.id, json: r.json, source: r.source, ingredients: r.ingredients, result: r.result }));
    const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'recipes-export.json'; a.click();
  });

  // Startup
  renderRecipeList();
})();
</script>

</body>
</html>
