----
sitemap: false
----
<!DOCTYPE html>
<html>
<head>
  <title>Typo Translator</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    input, textarea { width: 100%; padding: 8px; margin: 10px 0; }
    label { font-weight: bold; display: block; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Typo Translator (Seeded)</h1>

  <label for="seed">Seed:</label>
  <input type="number" id="seed" value="123">

  <label for="input">Original Text:</label>
  <textarea id="input" rows="2">TEST</textarea>

  <button onclick="encode()">Translate</button>
  <button onclick="decode()">Reverse</button>

  <label for="output">Result:</label>
  <textarea id="output" rows="2"></textarea>

  <script>
    const VOWELS = 'AEIOUYaeiouy';

    function isVowel(ch) {
      return VOWELS.includes(ch);
    }

    function seededRandom(seed) {
      return function () {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
      };
    }

    function groupSameType(word) {
      let groups = [];
      let current = '';
      let lastType = null;

      for (let i = 0; i < word.length; i++) {
        let ch = word[i];
        let type = isVowel(ch) ? 'v' : 'c';

        if (type === lastType || lastType === null) {
          current += ch;
        } else {
          groups.push(current);
          current = ch;
        }

        lastType = type;
      }
      if (current) groups.push(current);
      return groups;
    }

    function shuffleOrTrim(group, rand) {
      const chars = group.split('');
      let method = Math.floor(rand() * 3); // 0: shuffle, 1: trim, 2: same

      if (chars.length < 2) return group;

      if (method === 0) {
        // Shuffle
        for (let i = chars.length - 1; i > 0; i--) {
          const j = Math.floor(rand() * (i + 1));
          [chars[i], chars[j]] = [chars[j], chars[i]];
        }
        return chars.join('');
      } else if (method === 1) {
        // Trim 1 letter
        let index = Math.floor(rand() * chars.length);
        chars.splice(index, 1);
        return chars.join('');
      }
      return group; // unchanged
    }

    function encode() {
      const seed = parseInt(document.getElementById("seed").value);
      const input = document.getElementById("input").value;
      const rand = seededRandom(seed);

      const groups = groupSameType(input);
      const simplified = groups.map(g => shuffleOrTrim(g, rand)).join('');
      document.getElementById("output").value = simplified;
    }

    function decode() {
      const seed = parseInt(document.getElementById("seed").value);
      const output = document.getElementById("output").value;

      // NOTE: This decode is **theoretical**, actual full restoration needs:
      // - Remember original length of groups
      // - Store more metadata per transformation

      // For now, this shows the original structure and approximates:
      const rand = seededRandom(seed);
      const approxGroups = groupSameType(output);

      let reconstructed = approxGroups.map(g => {
        if (g.length === 1) return g;
        // Try padding with '_' or return as-is
        return g + '_'; // can't truly reverse without more info
      }).join('');

      document.getElementById("input").value = reconstructed;
    }
  </script>
</body>
</html>
